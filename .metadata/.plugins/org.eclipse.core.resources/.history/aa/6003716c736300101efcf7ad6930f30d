-- 1번 : 집계함수

-- 집계함수의 결과는 행의 1개
-- NULL은 포함시키지 않는다.

-- COUNT()
SELECT * FROM EMPLOYEES;

-- 전체 직원수를 확인할 때(행이 몇개 존재하는지 확인)
SELECT COUNT(*)
FROM EMPLOYEES;

-- 특정 부서 110번의 직원수 확인
-- DISTINCT 조건
SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES;

SELECT COUNT(*) AS "110번의 직원수"
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 110;

--  SUM() 집계함수
-- 모든 급여의 급여 총합 계산
SELECT SUM(SALARY)
FROM EMPLOYEES;

-- 부서별 급여 총합 계산
SELECT DEPARTMENT_ID, SALARY
FROM EMPLOYEES;

SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- AVG() 집계함수
SELECT AVG(SALARY)
FROM EMPLOYEES;

-- 부서별 평균급여와 총합급여, 부서별 인원 구하기
SELECT DEPARTMENT_ID, AVG(SALARY), SUM(SALARY), COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- MAX(), MIN() 집계함수
SELECT MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES;

-- NULL값은 포함되지 않음을 확인 -> COUNT / NULL값도 포함하고 해당 값을 0으로 넣는다. COUNT(NVL())
SELECT COUNT(COMMISSION_PCT), COUNT(NVL(COMMISSION_PCT, 0))
FROM EMPLOYEES;

SELECT [DISTINCT] 컬럼명 AS [별칭]
FROM 테이블명
WHERE 조건식
GROUP BY 그룹화 기준 컬럼
HAVING 
ORDER BY 정렬 기준 컬럼 [ASC OR DESC];

-- GROUP BY와 HAVING절

-- 평균 급여가 5000 이상인 부서 조회하기.
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
--WHERE AVG(SALARY) >= 5000 -- WHERE절에서는 집계함수 사용불가능.
GROUP BY DEPARTMENT_ID 

-- 평균 급여가 5000 이상인 부서 조회하기.
-- ROUND는 소수점 이하 자릿수 지정
SELECT DEPARTMENT_ID 부서, ROUND(AVG(SALARY), 2) 평균급여
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) >= 5000;

-- 부서별 급여 총합이 50000보다 작은 부서들만 내림차순으로 정렬
SELECT DEPARTMENT_ID, SUM(SALARY) 급여총합
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) < 50000
ORDER BY 급여총합 DESC;

CREATE TABLE TBL_STU_G(
	STU_ID NUMBER,
	STU_NAME VARCHAR2(100) NOT NULL,
	STU_PHONE VARCHAR2(14),
	STU_AGE NUMBER,
	STU_DEPT VARCHAR2(100),
	CONSTRAINT PK_STU_G PRIMARY KEY(STU_ID)
);

SELECT * FROM TBL_STU_G;

INSERT INTO TBL_STU_G
--VALUES (1, '조승우', '8901-8888', 30, '교육학과');
--VALUES (2, '이동욱', '9012-9999', 30, '컴퓨터 공학과');
--VALUES (3, '김소현', '9876-1234', 20, '방송연예과');
--VALUES (4, '김남길', '5050-1222', 26, '컴퓨터 공학과');
--VALUES (5, '강하늘', '5111-5151', 22, '방송연예과');
--VALUES (6, '공유', '5050-5151', 30, '컴퓨터 공학과');
--VALUES (7, '이종혁', '1213-2222', 34, '방송연예과');
--VALUES (8, '박은빈', '1213-2222', 20, '방송연예과');

SELECT * FROM TBL_STU_G;

-- 1) 학과 종류 검색 : DISTINCT는 중복을 제거하는 기능을 한다.
SELECT DISTINCT STU_DEPT
FROM TBL_STU_G;

-- 2) 각 학과별 학생수 조회
SELECT STU_DEPT 학과, COUNT(*) 학생 수
FROM TBL_STU_G
GROUP BY STU_DEPT;

-- 3) 각 학과별 평균나이 조회
-- ROUND(컬럼값, 소수점몇자리까지) 아래 경우는 3자리에서 반올림.
SELECT STU_DEPT 학과, ROUND(AVG(STU_AGE), 2) 평균나이
FROM TBL_STU_G
GROUP BY STU_DEPT;

-- 4) 26살 이상인 학생 전체 컬럼 조회(이름, 핸드폰번호, 나이, 학과로 별칭붙여서)
SELECT STU_NAME AS 이름, STU_PHONE AS 핸드폰번호, STU_AGE AS 나이, STU_DEPT AS 학과
FROM TBL_STU_G
WHERE STU_AGE >= 26

-- 4-1) 학과별로 26살 이상인 학생 전체 컬럼 조회(이름, 핸드폰번호, 나이, 학과로 별칭붙여서)
SELECT STU_DEPT AS 학과, COUNT(*) 학생수
FROM TBL_STU_G
WHERE STU_AGE >= 26
GROUP BY STU_DEPT

-- 5) 학생이름이 김으로 시작하거나 이로 시작하는 학생들의 학과별 수 조회
SELECT STU_DEPT 학과, COUNT(*) 학생수
FROM TBL_STU_G
WHERE STU_NAME LIKE '김%' OR STU_NAME LIKE '이%'
GROUP BY STU_DEPT;

-- 6) 컴퓨터 공학과의 학생 중 25살 이상인 학생 수 조회
-- 별칭은 30자 이하, 13글자이지만 UTP-8 2~3바이트 처리제한초과(오라클에서 자주 발생하는 문제)
SELECT COUNT(*) AS "25up컴공학생"
FROM TBL_STU_G
WHERE STU_DEPT = '컴퓨터 공학과' AND STU_AGE >= 25;


-- 3. ROWNUM : 인덱스(컬럼)처럼 사용할 수 있음.
SELECT ROWNUM, E.* FROM EMPLOYEES E;

SELECT ROWNUM, SALARY FROM EMPLOYEES;

-- EMPLOYEES 테이블에서 SALARY를 내림차순으로 정렬한 뒤 ROWNUM을 붙여서 조회하기.
SELECT ROWNUM, SALARY FROM EMPLOYEES 
ORDER BY SALARY DESC; -- 순서가 뒤죽박죽 섞여있는 문제

SELECT ROWNUM, E2.SALARY
FROM (SELECT * FROM EMPLOYEES E ORDER BY SALARY DESC) E2

-- 급여 1위 ~ 5위까지 전체 정보를 조회
SELECT ROWNUM, E2.*
FROM(SELECT * FROM EMPLOYEES E ORDER BY SALARY DESC) E2
WHERE ROWNUM BETWEEN 1 AND 5

-- 급여 6위 ~ 10위까지 전체 정보를 조회
SELECT ROWNUM, E2.*
FROM(SELECT * FROM EMPLOYEES E ORDER BY SALARY DESC) E2
WHERE ROWNUM BETWEEN 1 AND 10

SELECT ROWNUM, E2.*
FROM (SELECT ROWNUM AS RN, E.* 
	FROM (
		SELECT SALARY
		FROM EMPLOYEES
		ORDER BY SALARY DESC) E) E2
WHERE RN BETWEEN 6 AND 10;

-- 내부쿼리1 (가장 안쪽 서브쿼리 E) : EMPLOYEES 테이블에서 SALARY 기준 내림차순 정렬
SELECT SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC)


